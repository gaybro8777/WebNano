WebNano version 0.001

The design goal numer one here is to provide basic functionality that should cover most 
of use cases and a easy way to override it and extend.
The design goal number two is to delegate as much as possible to specialized
CPAN modules with minimal hassle.  

The main functionality is simple mapping (dispatching) of HTTP request paths into method
calls as in the following example:

    '/' -> 'MyApp::Controller->index_action()'
    '/page' -> 'MyApp::Controller->page_action()'
    '/Some/Very/long/path' -> 'MyApp::Controller::Some::Very->long_action( 'path' )

The name of the action subroutine needs to end with '_action' postfix or alternatively 
the mapping of the last part of the path to the subroutine name can be provided with
'url_map' which can be an array of sub names or a hash of mappings (like run_modes 
in CGI::Application).

The examples in 'extensions' show how one can extend this basic dispatching with
other dispatching 'flavours': 

WebDispatchTable shows how to create a DSL for dispatching (ala Dancer):

    get '/some_address' => sub { 'This is some_address in web_dispatch table' };

CodeAttributesForMeta shows how to add an 'Action' code attribute (ala Catalyst):

    sub index : Action { 'This is the index page' }

CRUD shows how to create an encapsulated CRUD controller code

This mapping is done inside Controller code - so it can be easily overridden
and extended on per directory basis.  This should allow one to create
self-contained controllers that fully encapsulate some specialized functionality.

CONTROLLER OBJECTS LIVE IN THE REQUEST SCOPE (NEW CONTROLLER PER REQUEST)

If you need to build a heavy
structure used in the controller you can always build it as the
application attribute and use it in the controller as it has access to
the application object, but since all the work of controllers is done
in the request scope (i.e. creating the request) - then it makes sense
that the whole object lives in that scope.  This is the same as
Tatsumaki handlers (and controllers in Rails, Django and probably
other frameworks) - but different from Catalyst.


DEPENDENCIES

The core of WebNano is based on Class::XSAccessor.
Beside that there are only minimal dependencies for the core - but there are
a couple of extensions illustrating how to implement different dispatching
methods and also for testing I use FormHandler and DBIC - those would eventually go into
examples and other distros but for now it is convenient for me to keep it in 
the main repository.


INSTALLATION

To install this module, run the following commands:

    perl Makefile.PL make make test make install


DEPENDENCIES

See Makefile.PL


COPYRIGHT AND LICENCE

Copyright (C) 2009, Zbigniew ≈Åukasiak

This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
